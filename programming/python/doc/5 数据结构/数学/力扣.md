# [412. Fizz Buzz](https://leetcode.cn/leetbook/read/top-interview-questions-easy/xngt85/)
```python
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        li = []
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                li.append("FizzBuzz")
            elif i % 3 == 0:
                li.append("Fizz")
            elif i % 5 == 0:
                li.append("Buzz")
            else:
                li.append(str(i))
        return li
```
# [204. 计数质数](https://leetcode.cn/problems/count-primes/description/)
## 方案一 枚举法（超时）
```python
class Solution:
    def countPrimes(self, n: int) -> int:
        def is_primes(n):
            i = 2
            while n > 2 and i * i <= n:
                if n % i == 0:
                    return False
                i += 1
            return True
        if n <= 2:
            return 0
        li = []
        for i in range(2, n):
            
            if is_primes(i):
                li.append(i)
            # print(li)
        return len(li)
```
## 方案二 埃氏筛
```python
class Solution:
    def countPrimes(self, n: int) -> int:
        # 当n位0或者1时，质数的个数是0
        if n < 2:
            return 0
        # 使用一个列表表示索引值是不是质数，0表示不是，1表示是，先假设所有数都是质数。
        primes = [1] * n
        # 我们上面推断，0和1时，都没有质数
        primes[0] = 0
        primes[1] = 0
        # 从2开始，遍历每个数，截止到根号n；
        # 为什么是根号n？
        # 1. 任何一个合数必然可以分解为两个数的乘机a*b，如果a，b都大于根号n，则乘机必然大于n；那么两个数中必然有一个数小于等于根号n；
        # 2. 根号n之后的数，如果是合数必然已经通过前面的筛选标记过了。除了被标记的剩下的数必然是质数；
        # 我们假设n=30，根号n是5.48
        # 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29
        # 2是质数，则排除2的倍数，4，6， 8， 10， 12， 14， 16， 18， 20， 22， 24， 26， 28；
        # 3是质数，排除3的倍数， 6（已经排除）， 9， 12（）， 15， 18（）， 21， 24（）， 27，
        # 4 不是质数
        # 5是质数，排除 10（）， 15（），20（），25，
        # 6是合数
        # 剩余的数：2,3,5，之后的，7,11， 13， 17， 19,23， 29
        # 10个
        # 为什么要加一？
        # range()右边是开区间，取不到最后一个数，比如n=10，i只能取2，这样就会把9作为质数
        for i in range(2, int((n**0.5)+1)):
            if primes[i]:
                # 这里的步长为什么是i呢？
                # 因为这里要排除i的倍数，所有i的倍数都应该进行排除
                primes[i*i: n: i] = [0]* len(primes[i*i: n: i])
        # 这里为什么要求和？
        # 我们标记的质数是1，所以这里恰好对列表求和，既是质数的数量
        return sum(primes)
```
# [326. 3 的幂](https://leetcode.cn/problems/power-of-three/description/)
## 方案一 试除法
```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        while n and n % 3 ==0:
            n //= 3
        return n == 1
```
## 方案二：判断是否为最大 3 的幂的约数
由题目可知，n是32位有符号数，这里指找32位数，3的最大幂；求n是否为最大数的因数
```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and 1162261467 % n == 0
```
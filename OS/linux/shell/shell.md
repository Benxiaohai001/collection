# if
-z ：后面跟一个字符串变量或者字符串常量，如果长度为零则为true；否则false \
-f ：后面添加一个文件名路径，如果存在返回true，否则返回false；\
-ne: 表示不等于 not equal \
-gt : 大于 \
-e：判断文件是否存在 \
#  #之后的各种参数
$# 传递给当前脚本的参数的个数\
$0 表示当前命令本身的脚本 \
$n 表示第n个参数 \
$!: 上一次执行的进程的PID \
$? 是一个特殊的变量，用于获取上一个命令的退出状态码。在Shell中，命令执行成功时会返回0，执行失败时会返回一个非零的状态码，通常是一个正整数。$? 变量用于获取最后一个执行的命令的退出状态码。 \
# tip
## shell 中 $变量名 和 ${变量名} 有什么区别
### 解答
在Shell脚本中，$变量名和${变量名}都是用来展开变量的。在大多数情况下，这两种方式是等效的，但是它们有以下区别：

当需要将变量名与其他字符连接在一起时，使用${变量名}可以更清晰地指定变量名的边界。例如，如果要将变量foo与后缀字符串.txt连接在一起，可以这样写：${foo}.txt。

当变量名与后面紧跟着的字符混淆时，使用${变量名}可以帮助Shell正确解释变量名。例如，如果要将变量foo与字符序列bar连接在一起，可以这样写：${foo}bar。如果使用$foo和bar之间没有空格来表示这个变量，Shell可能会将它们解释为一个名为foobar的变量。

在某些场合下，${变量名}可以用于指定特殊的变量属性，例如${#变量名}可以用来获取变量的长度，${变量名:offset:length}可以用来提取变量的子字符串。

总之，$变量名和${变量名}都可以用来展开变量，但在某些情况下使用${变量名}可以带来更好的可读性和可靠性。
## shell 中执行函数的方式有哪几种？ 
1.函数名；2.函数名； 3. $(函数名)

## shell 中的空格应该注意
```shell
if [ $1 == "add" ]; then
    echo "1"

else
    echo "2"
fi

# 第二种

if [$1 == "add" ]; then
    echo 1
else
    echo 2
fi

# 如上，虽然只是$1之前少了一个空格，但是执行路径完全不同；第二种方法是错误的
```
# set
set -e # 会在错误之处终止，但是不会打印任何信息；
set -x # 打印调试信息，有助于调试脚本
# 自加
((i++))
let i++

# &
* 后台执行命令
`
sleep 10 &
echo "This will be printed immediately" # 不会等待sleep执行完成就会直接输出
`
* 控制作业
``` bash
# 后台执行
sleep 10 &
# 展示后台执行的进程
jobs
# 将后台执行的进行移回到前台
fg
# 将后台暂停的作业继续在后台运行
bg %1
```
* 同时执行多个命令
* shell脚本中使用&（后台执行）
# shell脚本和terminal执行命令的异同
## 相同
* 命令语法
* 变量
* 控制结构
## 不同之处
* 脚本文件：终端是立即执行，脚本是一系列命令；
* 执行权限：shell脚本执行之前需要确保脚本有执行权限。`chmod +x script.sh`
* shebang行：shell执行之前通常shebang开头，执行脚本解释器。
* 调试和错误处理：shell脚本通常可以使用`set -e`和`set -x`等选项处理调试信息